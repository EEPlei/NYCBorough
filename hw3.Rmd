---
title: Homework 3
author: Duke Dinosaurs Team 4
date: "October 24, 2015"
output: html_document
---
1. Cleaning Data 
First obtain the data using the following code. 
```{r}
library(dplyr)
library(data.table)
library(magrittr)
library(stringr)
nyc = fread("/home/vis/cr173/Sta523/data/nyc/nyc_311.csv") %>% tbl_df()
```

Since we have such a large dataset, we begin by learning some things about our data. Then, we can begin cleaning the data, so we have accurate data to work with. 
Let's take a look at what kind of information our data tells us.     
`colnames(nyc)`
We'll get back the folowing results       
 [1] "Unique.Key"                     "Created.Date"                  
 [3] "Closed.Date"                    "Agency"                        
 [5] "Agency.Name"                    "Complaint.Type"                
 [7] "Descriptor"                     "Location.Type"                 
 [9] "Incident.Zip"                   "Incident.Address"              
[11] "Street.Name"                    "Cross.Street.1"                
[13] "Cross.Street.2"                 "Intersection.Street.1"         
[15] "Intersection.Street.2"          "Address.Type"                  
[17] "City"                           "Landmark"                      
[19] "Facility.Type"                  "Status"                        
[21] "Due.Date"                       "Resolution.Description"        
[23] "Resolution.Action.Updated.Date" "Community.Board"               
[25] "Borough"                        "Park.Facility.Name"            
[27] "Park.Borough"                   "School.Name"                   
[29] "School.Number"                  "School.Region"                 
[31] "School.Code"                    "School.Phone.Number"           
[33] "School.Address"                 "School.City"                   
[35] "School.State"                   "School.Zip"                    
[37] "School.Not.Found"               "School.or.Citywide.Complaint"  
[39] "Vehicle.Type"                   "Taxi.Company.Borough"          
[41] "Taxi.Pick.Up.Location"          "Bridge.Highway.Name"           
[43] "Bridge.Highway.Direction"       "Road.Ramp"                     
[45] "Bridge.Highway.Segment"         "Garage.Lot.Name"               
[47] "Ferry.Direction"                "Ferry.Terminal.Name"   
Since some of these aren't important, we'll subset our `nyc` data to just the following fourteen variables.
```{r}
nyc.important <- nyc[,c("Unique.Key",
                        "Complaint.Type",
                        "Descriptor",
                        "Incident.Zip",
                        "Incident.Address",
                        "Street.Name",
                        "Cross.Street.1",
                        "Cross.Street.2",
                        "Intersection.Street.1",
                        "Intersection.Street.2",
                        "Address.Type",
                        "City",
                        "Resolution.Description", "Borough")]
```

We can begin by subsetting out the two Street Intersection Columns.    
`test1 <- nyc.important$Intersection.Street.1 != ""`    
`test2 <- nyc.important$Intersection.Street.2 != ""`    
`> length(which(test1))`     
`[1] 1817002`     
`> length(which(test2))`     
`[1] 1816062`     
So we can see that there exists cases where Intersection.Street.1 has data but Intersetion.Street.2 does not. This may also be true vice-versa. 
```{r}
nyc1 <- filter(nyc.important, Cross.Street.1 != "" & Cross.Street.2 != "")
nyc1.1 <- filter(nyc1, Intersection.Street.1 == "" & Intersection.Street.2 == "")
```
Find all the data where both Cross Street Columns are filled. 
```{r}
nyc2 <- filter(nyc.important, Intersection.Street.1 != "" & Intersection.Street.2 != "")
nyc2.1 <- filter(nyc2, Cross.Street.1 == "" & Cross.Street.2 == "")
```
Find all the data where both Intersection Street Columns are filled.    
Now we have two subsets of our `nyc.important` data frame. We've thrown away the data where there isn't enough information. Now, we consider the possibility that there may be too much information. In this case, it would be the data where there is information for both Cross Street Columns as well as (both Intersection Street Columns. We can bind `nyc1` and `nyc2` together and throw away the data points where we have both cross and intersection information.    
```{r}
nyc3 <- bind_rows(nyc1.1, nyc2.1)
filter1 <- (nyc3$Intersection.Street.1 != "" & nyc3$Intersection.Street.2 != "" & nyc3$Cross.Street.1 != "" & nyc3$Cross.Street.2 != "")
nyc4 <- filter(nyc3, !filter1)
```
`filter1` selects all data points where any of the four columns are empty. In other words, filter1 will select all data points where all four columns are full.    
`> unique(nyc4$Borough)`
`"MANHATTAN"`     `"BRONX"         "BROOKLYN"      "QUEENS"        "STATEN ISLAND" `"Unspecified" `
```{r}
nyc5 <- filter(nyc4, Borough != "Unspecified")
```
Find all city names that has "new" in any combination of upper and lower case. Find all city names that has some variation of "york" in it. Note, we know that there is the variation "yok" because we saw it when looking at `sort(unique(nyc$City))`. It is entirely possible that we missed a variation of New York, but this is our best attempt. 
```{r}
new_indices <- which(str_detect(tolower(unique(nyc$City)), "new"))
york_indices <- which(str_detect(tolower(unique(nyc$City)[new_indices]), "york"))
yok_indices <- which(str_detect(tolower(unique(nyc$City)[new_indices]), "yok"))
names.okay <- c(unique(nyc$City)[new_indices][york_indices],unique(nyc$City)[new_indices][yok_indices] )
nyc6 <- filter(nyc5, City %in% names.okay)
```
Remove all BLOCKFACE Address Types. 
```{r}
nyc7 <- filter(nyc6, Address.Type != "BLOCKFACE")

```

