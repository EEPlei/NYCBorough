---
title: Homework 3
author: Duke Dinosaurs Team 4
date: "October 24, 2015"
output: html_document
---
##Geocoding##
First obtain the data using the following code `fread() %>% tbl_df()`
Since we have such a large dataset, we begin by learning some things about our data. Then, we can begin cleaning the data, so we have accurate data to work with. 
Let's take a look at what kind of information our data tells us.     
`colnames(nyc)`
We'll get back the folowing results       
 ` "Unique.Key"                     "Created.Date"`                  
 ` "Closed.Date"                    "Agency"`                        
 ` "Agency.Name"                    "Complaint.Type"`                
 ` "Descriptor"                     "Location.Type"`                 
 ` "Incident.Zip"                   "Incident.Address"`              
 ` "Street.Name"                    "Cross.Street.1"`                
 ` "Cross.Street.2"                 "Intersection.Street.1"`         
 ` "Intersection.Street.2"          "Address.Type"`                  
 ` "City"                           "Landmark"`                      
 ` "Facility.Type"                  "Status"`                        
 ` "Due.Date"                       "Resolution.Description"`        
 ` "Resolution.Action.Updated.Date" "Community.Board"`               
 ` "Borough"                        "Park.Facility.Name"`            
 ` "Park.Borough"                   "School.Name"`                   
 ` "School.Number"                  "School.Region"`                 
 ` "School.Code"                    "School.Phone.Number"`           
 ` "School.Address"                 "School.City"`                   
 ` "School.State"                   "School.Zip"`                    
 ` "School.Not.Found"               "School.or.Citywide.Complaint"`  
 ` "Vehicle.Type"                   "Taxi.Company.Borough"`          
 ` "Taxi.Pick.Up.Location"          "Bridge.Highway.Name"`           
 ` "Bridge.Highway.Direction"       "Road.Ramp"`                    
 ` "Bridge.Highway.Segment"         "Garage.Lot.Name"`               
 ` "Ferry.Direction"                "Ferry.Terminal.Name"`   
Since some of these aren't important, we'll subset our `nyc` data to just the following fourteen variables.
                        `"Unique.Key",`         
                        `"Complaint.Type",`          
                        `"Descriptor",`            
                        `"Incident.Zip",`           
                        `"Incident.Address",`            
                        `"Street.Name",`              
                        `"Cross.Street.1",`                   
                        `"Cross.Street.2",`                     
                        `"Intersection.Street.1",`                  
                        `"Intersection.Street.2",`                          
                        `"Address.Type",`                
                        `"City",`                      
                        `"Resolution.Description",`
                        `"Borough"`               
            
We can see that location information is available through two Cross Street columns or two Intersection Street columns. However, we shouldn't assume that all data points will have information in these columns. We should test to see if there exists cases where there are no information.    
`test1 <- nyc.important$Intersection.Street.1 != ""`    
`test2 <- nyc.important$Intersection.Street.2 != ""`    
`> length(which(test1))`     
`[1] 1817002`     
`> length(which(test2))`     
`[1] 1816062`     
So we can see that there may exist cases where Intersection.Street.1 has data but Intersetion.Street.2 does not. This may also be true vice-versa.    
The data that we want should either have both Cross Street data or both Intersection Street data. 
`nyc1` will filter out all nyc data where Cross.Street.1 is not empty and Cross.Street.2 is not empty. Since Intersection.Street.1 or Intersection.Street may also be full at the same time, we'll filter `nyc1` into `nyc1.1` by only taking the data points where both Intersection columns are empty.    
Similarily, `nyc2` will find all nyc data where Intersection.Street.1 is not empty and Intersection.Street.2 is not empty. `nyc2.1` will further filter the data by finding the ones where both Cross columns are empty. 

Find all the data where both Intersection Street Columns are filled.    
Now we have two subsets of our `nyc.important` data frame. We've thrown away the data where there isn't enough information. Now, we consider the possibility that there may be too much information. In this case, it would be the data where there is information for both Cross Street Columns as well as (both Intersection Street Columns. We can bind `nyc1` and `nyc2` together and throw away the data points where we have both cross and intersection information.    
`nyc3` binds `nyc1.1` and `nyc2.1`. Now we have a data frame where either both Cross Columns are full and both Intersection Columns are empty or both Intersection Columns are full and both Cross Columns are empty.    
`nyc4` makes sure that all data points has location information 
Let's now look at the Borough Column.       
`> unique(nyc4$Borough)`
`"MANHATTAN"`
`"BRONX"`         
`"BROOKLYN"`      
`"QUEENS"`        
`"STATEN ISLAND"` 
`"Unspecified"`
Since we are only interested in the first five boroughs, `nyc5` will filter out "Unspecified".    
Find all city names that has "new" in any combination of upper and lower case. Find all city names that has some variation of "york" in it. Note, we know that there is the variation "yok" because we saw it when looking at `sort(unique(nyc$City))`. It is entirely possible that we missed a variation of New York, but this is our best attempt.
Now we have a vector of names we can assume was meant to be New York City. We can filter out all data points whose City Column entry is not one of those names - `nyc6`.
By now, we've realized that each data's location data is given to us differently. Looking at the Address.Type column, we can have some idea how the data is presented to us.     
`> unique(nyc$Address.Type)`    
`[1] ""  "ADDRESS" "INTERSECTION" "LATLONG" "BLOCKFACE" "PLACENAME"`     
We only want to work with ""Address", "Intersection", and "Placename". `nyc7` and `nyc7.1` will remove all data whose Address.Type Column isn't that of the three above. 
